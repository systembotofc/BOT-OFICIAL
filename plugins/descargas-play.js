import fg from 'api-dylux'; import { youtubedl, youtubedlv2 } from '@bochilteam/scraper'; import yts from 'yt-search'; import fetch from 'node-fetch'; let handler = async (m, { conn, args, usedPrefix, text, command }) => { let lister = ["mp3", "mp4", "mp3doc", "mp4doc"]; let [feature, inputs, inputs_, inputs__, inputs___] = text.split(" "); if (command == "play" || command == 'play2') { if (!text) return conn.reply(m.chat, `*\`â•­â”â°â° ğ’ğ˜ğ’ğ“ğ„ğŒ ğ— â±â±â”â•®\`*\nğ‘½ğ’–ğ’†ğ’ğ’—ğ’† ğ’‚ ğ’–ğ’”ğ’‚ğ’“ ğ’†ğ’ ğ’„ğ’ğ’ğ’‚ğ’ğ’…ğ’ ğ’‘ğ’†ğ’“ğ’ ğ’‚ğ’„ğ’ğ’ğ’‘ğ’‚Ã±ğ’‚ğ’…ğ’ ğ’…ğ’†ğ’ ğ’•ğ’Šğ’•ğ’–ğ’ğ’ + ğ’†ğ’ ğ’‚ğ’–ğ’•ğ’ğ’“.\nğ‘¬ğ’‹ğ’†ğ’ğ’‘ğ’ğ’: .ğ’‘ğ’ğ’‚ğ’š ğ‘«ğ’†ğ’—ğ’–ğ’†ğ’ğ’—ğ’†ğ’ğ’† ğ’‚ ğ’ğ’Š ğ’„ğ’‰ğ’Šğ’„ğ’‚ - ğ‘¯ğ’ğ’ğ’ƒğ’“ğ’†ğ’”ğ‘®`, m); await m.react('ğŸ•“'); var res = await yts(text); var vid = res.videos[0]; var q = '128kbps'; const texto1 = `*\`â•­â”ã€” ğ’ğ˜ğ’ğ“ğ„ğŒ ğ— ã€•â”â•®\`*\nâ”ƒâ” *ğŸ´ğ‘»ğ’Šğ’•ğ’–ğ’ğ’:* ${vid.title}\nâ”ƒâ” *ğŸ‘¤ğ‘¨ğ’–ğ’•ğ’ğ’“:* ${vid.author.name}\nâ”ƒâ” *â°ğ‘«ğ’–ğ’“ğ’‚ğ’„ğ’Šğ’ğ’:* ${vid.timestamp}\nâ”ƒâ” *ğŸ‘€ğ‘½ğ’Šğ’”ğ’Šğ’•ğ’‚ğ’”:* ${vid.views}\nâ”ƒâ” *ğŸ—“ğ‘·ğ’–ğ’ƒğ’ğ’Šğ’„ğ’‚ğ’…ğ’:* ${vid.ago}\nâ”ƒâ” *â—ğ‘¼ğ’“ğ’:* ${'https://youtu.be/' + vid.videoId}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â•¯`.trim(); await conn.sendButton(m.chat, texto1, wm, res.videos[0].thumbnail, [['ğŸ§ğƒğ„ğ’ğ‚ğ€ğ‘ğ†ğ€ğ‘ ğ€ğ”ğƒğˆğ', `${usedPrefix}mp3 ${text}`], ['ğŸ¥ğƒğ„ğ’ğ‚ğ€ğ‘ğ†ğ€ğ‘ ğ•ğˆğƒğ„ğ', `${usedPrefix}mp4 ${text}`]], null, [['ğ‚ğ€ğğ€ğ‹ ğ’ğ˜ğ’ğ“ğ„ğŒ ğ—', `${md}`]], m); } if (command == "mp3") { if (!text) return conn.reply(m.chat, `*\`â•­â”â°â° ğ’ğ˜ğ’ğ“ğ„ğŒ ğ— â±â±â”â•®\`*\n> ğ‘½ğ’–ğ’†ğ’ğ’—ğ’† ğ’‚ ğ’–ğ’”ğ’‚ğ’“ ğ’†ğ’ ğ’„ğ’ğ’ğ’‚ğ’ğ’…ğ’ ğ’‘ğ’†ğ’“ğ’ ğ’‚ğ’„ğ’ğ’ğ’‘ğ’‚Ã±ğ’‚ğ’…ğ’ ğ’…ğ’†ğ’ ğ’•ğ’Šğ’•ğ’–ğ’ğ’ + ğ’†ğ’ ğ’‚ğ’–ğ’•ğ’ğ’“.\n> ğ‘¬ğ’‹ğ’†ğ’ğ’‘ğ’ğ’: .ğ’‘ğ’ğ’‚ğ’š ğ‘«ğ’†ğ’—ğ’–ğ’†ğ’ğ’—ğ’†ğ’ğ’† ğ’‚ ğ’ğ’Š ğ’„ğ’‰ğ’Šğ’„ğ’‚ - ğ‘¯ğ’ğ’ğ’ƒğ’“ğ’†ğ’”ğ‘®`, m); try { const res = await yts(text); const vid = res.videos[0]; const q = '128kbps'; let yt = await fg.yta(vid.url, q); let { title, dl_url, size } = yt; let limit = 100; if (size.split('MB')[0] >= limit) return conn.reply(m.chat, `El archivo pesa mas de ${limit} MB, se cancelÃ³ la Descarga.`, m).then(_ => m.react('âœ–ï¸')); await conn.sendMessage(m.chat, { audio: { url: dl_url }, mimetype: "audio/mp4", fileName: vid.title + '.mp3', quoted: m, contextInfo: { 'forwardingScore': 200, 'isForwarded': true, externalAdReply: { showAdAttribution: false, title: `${vid.title}`, body: `${vid.author.name}`, mediaType: 2, sourceUrl: `${vid.url}`, thumbnail: await (await fetch(vid.thumbnail)).buffer() } } }, { quoted: m }); await m.react('âœ…'); } catch { try { let yt = await fg.ytmp3(vid.url, q); let { title, dl_url, size } = yt; let limit = 100; if (size.split('MB')[0] >= limit) return conn.reply(m.chat, `El archivo pesa mas de ${limit} MB, se cancelÃ³ la Descarga.`, m).then(_ => m.react('âœ–ï¸')); await conn.sendMessage(m.chat, { audio: { url: dl_url }, mimetype: "audio/mp4", fileName: vid.title + '.mp3', quoted: m, contextInfo: { 'forwardingScore': 200, 'isForwarded': true, externalAdReply: { showAdAttribution: false, title: `${vid.title}`, body: `${vid.author.name}`, mediaType: 2, sourceUrl: `${vid.url}`, thumbnail: await (await fetch(vid.thumbnail)).buffer() } } }, { quoted: m }); await m.react('âœ…'); } catch (error) { await conn.reply(m.chat, `*â˜“ OcurriÃ³ un error inesperado*\n\n` + error, m).then(_ => m.react('âœ–ï¸')); console.error(error); } } } if (command == "mp4") { if (!text) return conn.reply(m.chat, `*\`â•­â”â°â° ğ’ğ˜ğ’ğ“ğ„ğŒ ğ— â±â±â”â•®\`*\n> ğ‘½ğ’–ğ’†ğ’ğ’—ğ’† ğ’‚ ğ’–ğ’”ğ’‚ğ’“ ğ’†ğ’ ğ’„ğ’ğ’ğ’‚ğ’ğ’…ğ’ ğ’‘ğ’†ğ’“ğ’ ğ’‚ğ’„ğ’ğ’ğ’‘ğ’‚Ã±ğ’‚ğ’…ğ’ ğ’…ğ’†ğ’ ğ’•ğ’Šğ’•ğ’–ğ’ğ’ + ğ’†ğ’ ğ’‚ğ’–ğ’•ğ’ğ’“.\n> ğ‘¬ğ’‹ğ’†ğ’ğ’‘ğ’ğ’: .ğ’‘ğ’ğ’‚ğ’š ğ‘«ğ’†ğ’—ğ’–ğ’†ğ’ğ’—ğ’†ğ’ğ’† ğ’‚ ğ’ğ’Š ğ’„ğ’‰ğ’Šğ’„ğ’‚ - ğ‘¯ğ’ğ’ğ’ƒğ’“ğ’†ğ’”ğ‘®`, m); try { const res = await yts(text); const vid = res.videos[0]; const q = '360p'; let yt = await fg.ytv(vid.url, q); let { title, dl_url, size } = yt; let limit = 100; if (size.split('MB')[0] >= limit) return conn.reply(m.chat, `El archivo pesa mas de ${limit} MB, se cancelÃ³ la Descarga.`, m).then(_ => m.react('âœ–ï¸')); await conn.sendMessage(m.chat, { video: { url: dl_url }, mimetype: "video/mp4", fileName: vid.title + '.mp4', quoted: m, contextInfo: { 'forwardingScore': 200, 'isForwarded': true, externalAdReply: { showAdAttribution: false, title: `${vid.title}`, body: `${vid.author.name}`, mediaType: 2, sourceUrl: `${vid.url}`, thumbnail: await (await fetch(vid.thumbnail)).buffer() } } }, { quoted: m }); await m.react('âœ…'); } catch { try { let yt = await fg.ytv2(vid.url, q); let { title, dl_url, size } = yt; let limit = 100; if (size.split('MB')[0] >= limit) return conn.reply(m.chat, `El archivo pesa mas de ${limit} MB, se cancelÃ³ la Descarga.`, m).then(_ => m.react('âœ–ï¸')); await conn.sendMessage(m.chat, { video: { url: dl_url }, mimetype: "video/mp4", fileName: vid.title + '.mp4', quoted: m, contextInfo: { 'forwardingScore': 200, 'isForwarded': true, externalAdReply: { showAdAttribution: false, title: `${vid.title}`, body: `${vid.author.name}`, mediaType: 2, sourceUrl: `${vid.url}`, thumbnail: await (await fetch(vid.thumbnail)).buffer() } } }, { quoted: m }); await m.react('âœ…'); } catch (error) { await conn.reply(m.chat, `*â˜“ OcurriÃ³ un error inesperado*\n\n` + error, m).then(_ => m.react('âœ–ï¸')); console.error(error); } } }; export default handler;
